--- opcja_swap.cpp	2016-02-23 14:45:00.000000000 +1100
+++ opcja.cpp	2016-08-04 11:37:24.355414938 +1000
@@ -2,47 +2,119 @@
 
 #include "opcja.h"
 
+void opcja :: execute(lattice* sample,string name,vector<double>&parameters){
 
-int opcja :: choose_typ(plaster& bin){
+//		opt_equi.init(_sample, do_equi_step, od_kod, do_kod, co_ile_bin,bin_direction,move_sim_region);
+
+	if(name=="EQUILIBRATE"){
+		this->init(sample,parameters);
+	}
+	else if(name=="RESERVUAR"){
+		this->init_reservuar(parameters);
+	}
+	else{
+		control_output<<"No posibility of doing "<<name<<" as an option."<<endl;
+	}
+
+}
+
+
+int opcja :: choose_typ(plaster& bin, bool sig){
 	
-	int A = bin.size(1);
-	int B = bin.size(2);
+	int A =  bin.size(1);
+	int B =  bin.size(2);
 	int SIZE = A + B;
-	int TYP = 0;
+	int TYP = -1;
 			
-//	control_output<<" rozmiar typow 1/2 "<<A<<"/"<<B;
-	long N=(long)(rnd()*(SIZE));
-	if(N <= A){
+//	control_output<<" rozmiar typow 1/2 "<<A<<"/"<<B<<" "<<SIZE<<" ";
+	long N=(long)(rnd()*(SIZE))+1;
+	if((A > 0) and (0 < N) and (N <= (A+1))){
 		TYP=1;
 //		control_output<<" nr wylosowanego situ A: "<<N<<" "<<TYP;
 	}
-	else if(N > A and N <= SIZE){
-		N-=A;
+	else if((B > 0) and ((A+1) <= N) and (N <= (SIZE+1))){
+//		N-=A;
 		TYP=2;
 //		control_output<<" nr wylosowanego situ B: "<<N<<" "<<TYP;
 	}
-	else{control_output<<"ERROR in opcja::create: "<<N<<" "<<SIZE<<endl;exit(1);}
-	
-	return TYP;
+	else if(sig){control_output<<"Error in opcja::choose_typ: "<<N<<" "<<A<<" "<<B<<" "<<SIZE<<endl;
+		control_output<<"Try to remove atom witch does not egzist "<<endl;exit(1);}
+	else if(!sig){control_output<<"Warrning in opcja::choose_typ: "<<N<<" "<<A<<" "<<B<<" "<<SIZE<<endl;
+		control_output<<"Try to remove atom witch does not egzist "<<endl;}
+
+//	control_output<<N<<" "<<TYP<<endl;
+	return TYP;			//TYP < 0 means that there is no atoms in the bin
 }
 
 
 int opcja :: check_stech(double _stech, double _vac, double _size){
 	
 //	control_output<<"check_stech..."<<endl;
-	int status=0;
+	double status=0;
 	//iterowac po equi_curve[stech][vac]
 	//szukam wartosci vac dla danego stech
 			//przelicz koncentracje na ilosc: 
 	double _eq_vac = Ceq_vac(_stech);
+	double _err_vac = errCeq_vac(_stech);
 	//long size = get_sample_size();
-	long int vac=(_vac)*(_size);
-	long int eq_vac=(_eq_vac)*(_size);
-	status = int(eq_vac - vac);	
+//	int err = (err_vac)*_size;
+	double vac=(_vac)*(_size);
+//	int eq_vac=(_eq_vac)*(_size);
+	double delta_left = ((_eq_vac - _err_vac)*_size);
+	double delta_right = ((_eq_vac + _err_vac)*_size);
+	if(vac < delta_left){
+		status=delta_left-vac;
+	}
+	else if(vac > delta_right){
+		status=delta_right-vac;
+	}
+	else{
+		status=0;
+	}	
 //	control_output<<" stech "<<_stech<<" vac "<<_vac<<" status "<<status<<endl;
-	return status;	//if < 0 then must remove vac in plaster
+	return round(status);	//if < 0 then must remove vac in plaster
 }					//if > 0 then must create vac in plaster
 
+double opcja :: errCeq_vac(double stech){
+//	control_output<<"call Ceq_vac("<<stech<<")"<<endl;
+	double a=0,b=0,CV=0.0;
+	double eq_stech1 = 0.0;
+	double eq_stech2 = 0.0;
+	double eq_vac1 = 0.0;
+	double eq_vac2 = 0.0;
+	int size = (equi_curve.size()-1);
+//	control_output<<"Ceq_vac ranges"<<endl;
+//	for (int i=0; i <= size;i++){
+//		eq_stech1 = equi_curve[i][0];
+//		eq_vac1 = equi_curve[i][1];
+//		control_output<<i<<" "<<eq_stech1<<" "<<eq_vac1<<endl;
+//	}
+	if(equi_curve[0].size() < 2){control_output<<"ERROR in opcja::errCeg_vac"<<endl;exit(1);}
+
+	if(stech < equi_curve[0][0]){CV=equi_curve[0][2];}
+	else if(stech > equi_curve[size][0]){
+		//control_output<<"test: "<<equi_curve[size][0]<<endl;
+		CV=equi_curve[size][2];}
+	else{
+	for (int i=1; i <= size;i++){
+		eq_stech1 = equi_curve[i-1][0];
+		eq_stech2 = equi_curve[i][0];
+		if(eq_stech1 <= stech and eq_stech2 >= stech ){	//zakladam ze rosnaco jest stech w pliku
+//			control_output<<" for "<<i;
+			//fitowanie prostej do 2 punktow i szukanie dokladnej wartosci vac
+				eq_vac1 = equi_curve[i-1][2];
+				eq_vac2 = equi_curve[i][2];		
+				a = (eq_vac2 - eq_vac1)/(eq_stech2 - eq_stech1);
+				b = eq_vac1 - eq_stech1*a;
+//				control_output<<" a "<<a<<" b "<<b<<" eq_vac "<<(a*stech+b)<<endl;
+				break;
+		}
+	}
+		CV=(a*stech+b);
+	}
+//	control_output<<" a "<<a<<" b "<<b<<" eq_vac "<<CV<<endl;
+	return CV;
+}
 double opcja :: Ceq_vac(double stech){
 	
 //	control_output<<"call Ceq_vac("<<stech<<")"<<endl;
@@ -58,7 +130,7 @@
 //		eq_vac1 = equi_curve[i][1];
 //		control_output<<i<<" "<<eq_stech1<<" "<<eq_vac1<<endl;
 //	}
-
+	if(equi_curve[0].size() < 1){control_output<<"ERROR in opcja::Ceg_vac"<<endl;exit(1);}
 	if(stech < equi_curve[0][0]){CV=equi_curve[0][1];}
 	else if(stech > equi_curve[size][0]){
 		//control_output<<"test: "<<equi_curve[size][0]<<endl;
@@ -86,7 +158,7 @@
 
 bool opcja :: check_rezervuars(int i, int TYP){
 	
-	int typ_od=TYP,typ_do=TYP,status=0, ile_to_move=-1;
+	int typ_od=TYP,typ_do=TYP;	//,status=0;	//, ile_to_move=-1;
 	bool do_move=false;
 	long int V=0, Z=0;
 		
@@ -95,14 +167,14 @@
 //		A+=reservuars[i].eq_flux_get(t);}
 //		Z=A;
 //	}else{
-		V = reservuars[i].eq_flux_get(0);
-		Z=abs(V)+1;
+		V = reservuars[i].eq_flux_get(0) + reservuars[i].flux_net_get(0);
+		Z=labs(V)+1;
 //		}	
 	
 	
 	
 	
-	if(Z > ROZMIAR[i]){//calkowita zmiana atomow wynosi tyle co 80% jednej plaszczyzny
+	if(Z > ROZMIAR[i]){//calkowita zmiana atomow wynosi tyle co 100% jednej plaszczyzny
 
 			if(V>0)	//dV>0 to znaczy ze w rezerwuarze powstala nowa plaszczyzna wakancji -> probka w strone atomow
 			{TYP_TO_MOVE=1;}
@@ -112,9 +184,12 @@
 			do_move=true;
 			MOVE_FRAME=true;	//set global variable to true
 			REZ_TO_MOVE=i;	//set global var. which rezervuar to move
-			status=1;}
-	else{	//jesli nie ma nowej plaszczyzny ale zabraklo atomow typu TYP w rezerwuarze
+			//status=1;
+			}
+	else{	//jesli nie ma nowej plaszczyzny ale zabraklo atomow typu TYP w rezerwuarze		<< nie mozliwy scenariusz bo typ losowany z rezerwuaru
 		if(reservuars[i].check(typ_od,typ_do,1)){	//ale jesli brakuje typow
+		
+		control_output<<"warrning in opcja::check_reservuars -> try remove typ which dose not exist in reservuar "<<TYP<<endl;
 			if(TYP>0)	//TYP>0 to znaczy ze w rezerwuarze zabraklo atomow -> probka w strone atomow
 			{TYP_TO_MOVE=1;}
 			else if(TYP==0)		//TYP==0 to znaczy ze w rezerwuarze zabraklo wakancji -> probka w strone wakancji
@@ -123,7 +198,7 @@
 			do_move=true;
 			MOVE_FRAME=true;	//set global variable to true
 			REZ_TO_MOVE=i;	//set global var. which rezervuar to move
-			status=2;
+			//status=2;
 		}
 	}
 //	if(MOVE_FRAME or SINGLE){control_output<<"|<"<<TYP<<"|"<<i<<"|"<<V<<"|"<<Z<<"|"<<ROZMIAR[i]<<"|"<<status;}
@@ -135,7 +210,7 @@
 
 	if(MOVE_FRAME or SINGLE){control_output<<" c: "<< ile;}
 	bool MOVE = false;
-	int rez = 0, j = -1;
+	int rez = -1, j = -1;
 	
 	for( int i=0; i<(ile);i++){
 //		for( int j=1;j<3;j++){		//MOZNA ZROBIC W ZALEZNOSCI OD TYPOW
@@ -159,10 +234,10 @@
 			while(1){
 			N1=(long)(rnd()*(BLOKS[nr].size(j)));
 			rnd_at=BLOKS[nr].get_site(j,N1);
-
+			control_output<<" ctyp: "<<rnd_at->get_atom()<<endl;
 			
 			double d = 0.0, distanceL = 0.0, distanceR = 0.0;
-			rez = 0;
+			
 
 			if(BIN_DIRECTION==1)
 			{
@@ -278,7 +353,7 @@
 	
 	//direct exchange dla rezerwuarow	//DODAC PARALLEL
 	double beta=1.0/(kB*TEMPERATURE);
-	for(int i=0;i<reservuars.size();i++){	
+	for(unsigned int i=0;i<reservuars.size();i++){	
 		long Nsize=reservuars[i].size();
 	//	cout<<"rez: "<<i<<" size: "<<Nsize<<endl;
 		for (long iter=0; iter<steps; iter++){
@@ -309,19 +384,126 @@
 	}		
 }
 
+void opcja :: create_vac_new(int nr, int ile_at, bool &FLAG){
+
+	if(ile_at<0){ile_at=ile_at*-1;}
+	unsigned int ile=ile_at;
+	if(MOVE_FRAME or SINGLE){control_output<<" c: "<< ile;}
+	bool MOVE = false;
+	int rez = -1, j = -1;
+//	control_output<<"TRYB: "<<TRYB<<endl;
+//	vector <int> wybrane_typy; wybrane_typy.reserve(20);
+//	for( int i=0; i<(ile);i++){
+//		j=choose_typ(BLOKS[nr]);
+//		wybrane_typy.push_back(j);
+//	}
+//	control_output<<"c: "<<nr<<" "<<ile<<": ";
+//	for(int i=0;i<wybrane_typy.size();i++){
+//	control_output<<wybrane_typy[i];
+//	}
+//	control_output<<endl;
+
+	for(unsigned int i=0; i<ile;i++){
+//		for( int j=1;j<3;j++){		//MOZNA ZROBIC W ZALEZNOSCI OD TYPOW
+			long N1,N2;
+			site* rnd_vac=0;
+			site* rnd_at=0;
+			j=choose_typ(BLOKS[nr]);
+	//		j=wybrane_typy[i];	//losuje typ atomu do wymiany z wakancja
+	//		control_output<<"rozmiar typow "<<0<<" w bloku "<<bloks[nr].size(0);
+	//		control_output<<" rozmiar typow "<<j<<" w bloku "<<bloks[nr].size(j);
+			if(BLOKS[nr].size(j) <= 0){
+				control_output<<endl;
+				control_output<<"ERROR: in opcja::create_vac -> you want to remove \
+				element "<<j<<" that does not exist in blok\n	\
+				Probably error in opcja::init or opcja::reinit_bloks"<<endl; 
+				cout<<endl;
+				cout<<"ERROR: in opcja::create_vac -> you want to remove \
+				element "<<j<<" that does not exist in blok\n	\
+				Probably error in opcja::init or opcja::reinit_bloks"<<endl;exit(1);
+			}
+			
+			N1=(long)(rnd()*(BLOKS[nr].size(j)));
+			rnd_at=BLOKS[nr].get_site(j,N1);
+	//		control_output<<" ctyp: "<<rnd_at->get_atom()<<" "<<nr<<endl;
+			
+			if(TRYB==1){ //swap
+				rez=choose_reservuar(rnd_at);
+				MOVE = check_rezervuars(rez,0);	//sprawdz rezerwuwar pod katem dostepnych wakancji
+		//		control_output<<"MOVE: "<<MOVE<<" rez: "<<rez<<endl;
+				if (!MOVE){
+					N2=(long)(rnd()*(reservuars[rez].size(0)));
+					rnd_vac = reservuars[rez].get_site(0,N2);
+					rnd_vac->set_atom(j);			
+					rnd_vac->reset_site();
+					reservuars[rez].delete_site(0,N2);
+					reservuars[rez].add_site(j,rnd_vac);
+					
+					rnd_at->set_atom(0);
+					rnd_at->reset_site();
+					BLOKS[nr].delete_site(j,N1);
+					BLOKS[nr].add_site(0,rnd_at);
+					BLOKS[nr].prob_update(j,1);
+					Vtoadd.push_back(rnd_at);	
+				}else{
+					//	if(MOVE_FRAME or SINGLE){control_output<<"||"<<BLOKS[nr].size(j)<<"|"<<reservuars[rez].size(0)<<"|"<<reservuars[rez].size(j)<<"|"<<Vtoadd.size()<<">|";}
+					break;
+				}
+					
+			}else if(TRYB==0){//convert
+				rnd_at->set_atom(0);
+				rnd_at->reset_site();
+				BLOKS[nr].delete_site(j,N1);
+				BLOKS[nr].add_site(0,rnd_at);
+				BLOKS[nr].prob_update(j,1);
+				Vtoadd.push_back(rnd_at);	
+			}
+	}//for(j=delta)
+	
+	if(MOVE_FRAME or SINGLE){control_output<<endl;}
+	if(MOVE){
+		FLAG = true;		//set local FLAG in do_equi_vac
+		do_equi_vac();		//rekurencja. Na poczatku sprawdza czy MOVE_FRAME set to TRUE.
+	}
+}
+
+
+int opcja :: choose_reservuar(site* atom){
+		
+	double d = 0.0, distanceL = 0.0, distanceR = 0.0;
+	int rez = -1;
+	d=atom->get_position(BIN_DIRECTION);			
+	distanceL = abs(d - BIN_ST);
+	distanceR = abs(d - BIN_END);
+	//	cout<<"Absloute value of distance L/R: "<<distanceL<<"/"<<distanceR<<endl;
+		
+	if(distanceL > distanceR){
+		rez = 1;
+	}else if(distanceL < distanceR){
+		rez = 0;
+	}else if(distanceL == distanceR){
+		double Q = rnd();
+		if(Q<=0.5){rez = 0;}else{rez = 1;}
+	}else{
+		cout<<"Wrong direction number in opcja::convert() "<<distanceL<<"/"<<distanceR<<endl;
+		exit(1);
+	}
+	return rez;
+}
+
 void opcja :: do_equi_vac(){
 
 	bool LOCAL_MOVE = false;
 	if(MOVE_FRAME or SINGLE){	
 	control_output<<"Rownowarze: "<<LOCAL_MOVE<<"|"<<MOVE_FRAME<<endl;
-	refresh();}
+	refresh(1);}
 	
 	if(MOVE_FRAME){
 		move_frame();	//do_move resetuje global MOVE_FRAME
 	}
 
-	//dla kazdego plasterka policzyc stech i sprawdzic warunek z curve
-	for (int i=0;i<BLOKS.size();i++){
+//	control_output<<"Rownowaga: "<<endl;
+	for (unsigned int i=0;i<BLOKS.size();i++){
 	//	bloks[i].calc_stech();
 		if(MOVE_FRAME or SINGLE)
 		{control_output<<i;}
@@ -334,11 +516,11 @@
 		//delta_vac if < 0 then must remove vac in plaster
 		//delta_vac if > 0 then must create vac in plaster
 		
-
+//		control_output<<i<<" "<<stech<<" "<<vac<<" "<<size<<" "<<delta_vac<<" "<<endl;
 //lokalna zmienna MOVE zeby ominuac pozostale bloki
 		
 		if(delta_vac < 0){
-			remove_vac(i,-delta_vac, LOCAL_MOVE);
+			remove_vac_new(i,-delta_vac, LOCAL_MOVE);
 		}
 		else if (delta_vac == 0)
 		{
@@ -347,49 +529,125 @@
 		}
 		else if ( delta_vac > 0 )
 		{
-			create_vac(i,delta_vac, LOCAL_MOVE);
+			create_vac_new(i,delta_vac, LOCAL_MOVE);
 		}
 		else{
 			cout<<"Error with equilibrate vacancy opcja::do_equi_vac()"<<endl;
 			exit(1);
 		}
 		
+		
+		
 		if(LOCAL_MOVE){
 			control_output<<" po: "<<i<<"|"<<LOCAL_MOVE<<"|"<<MOVE_FRAME<<endl;
 			break;}	//jesli bylo do_move przestan rownowazyc pozostale bloki
 	}	//for bloks
+	
+//	refresh(1);
+//	control_output<<"Koniec Rownowaga!"<<endl;
 			if(!LOCAL_MOVE){
 			if(MOVE_FRAME or SINGLE){
 			control_output<<" po: all|"<<LOCAL_MOVE<<"|"<<MOVE_FRAME<<endl;}}
 	//uaktulanic liste wakancji w  resident !!!!!!!!!!!! UWAGA !!!!!!!!!	
 }
 
-void opcja :: flux_add(site* vac_after_jump,site* atom_after_jump){
+void opcja :: equilibrate(vector <site*> &kontener, long steps){
+	
+	refresh(0);
+	do_equi_vac();
+	do_equi_rez(steps);
+	refresh_sim_area(kontener);
+
+	
+}
 
-	double x_A = atom_after_jump->get_position(BIN_DIRECTION);
-	double x_V = vac_after_jump->get_position(BIN_DIRECTION);
-	int id_A=0,id_V=0, typ=atom_after_jump->get_atom();
+void opcja :: flux_net_add(double pos_V, double pos_A, int typ, vector<plaster>& layer){
+	int id_A=-2,id_V=-2;							
 	//znajdz index bin dla x_A oraz x_V
-	for(int i=0; i< BLOKS.size(); i++){
-		if(BLOKS[i].get_st() <= x_A  and x_A < BLOKS[i].get_end()){
+	for(unsigned int i=0; i< layer.size(); i++){
+		if(layer[i].get_st() <= pos_A  and pos_A < layer[i].get_end()){
 			id_A=i;
 		}
-		if(BLOKS[i].get_st() <= x_V  and x_V < BLOKS[i].get_end()){
+		if(layer[i].get_st() <= pos_V  and pos_V < layer[i].get_end()){
 			id_V=i;
 		}
 	}
-	if(id_V != id_A){
+	if(id_V >=0 and (id_V != id_A)){
 		//vakancja pojawia sie w plastrze id_V oraz atom znika z plastra id_V
-		BLOKS[id_V].flux_delta(typ, 0);
-		BLOKS[id_V].flux_delta(0, 1);
+		layer[id_V].flux_net_delta(typ, 0);
+		layer[id_V].flux_net_delta(0, 1);
+	}
+	if(id_A >=0 and (id_V != id_A)){
 		//vakancja znika z plastra id_A oraz atom pojawia sie w plastrze id_A
-		BLOKS[id_A].flux_delta(typ, 1);
-		BLOKS[id_A].flux_delta(0, 0);
+		layer[id_A].flux_net_delta(typ, 1);
+		layer[id_A].flux_net_delta(0, 0);
+	}	
+}
+
+void opcja :: flux_add(double pos_V, double pos_A, int typ, vector<plaster>& layer){
+	int id_A=-2,id_V=-2;
+	double dir = pos_V - pos_A;	//if > 0 - wakancja skoczyla z lewej strony na prawa. Strumien dla wakancji jest +
+								//													  Strumien dla atomu jest -
+	//znajdz index bin dla x_A oraz x_V
+	for(unsigned int i=0; i< layer.size(); i++){
+		if(layer[i].get_st() <= pos_A  and pos_A < layer[i].get_end()){
+			id_A=i;
+		}
+		if(layer[i].get_st() <= pos_V  and pos_V < layer[i].get_end()){
+			id_V=i;
+		}
 	}
+	if(id_V >=0 and (id_V != id_A)){
+		//vakancja pojawia sie w plastrze id_V oraz atom znika z plastra id_V
+	//	layer[id_V].flux_net_delta(typ, 0);
+	//	layer[id_V].flux_net_delta(0, 1);
+		if(dir > 0){	//wakancja wplynela z lewej strony; atom wyplyna w lewo
+			layer[id_V].flux_net_delta(0, 1);
+			layer[id_V].flux_net_delta(typ, 0);
+		}
+		if(dir < 0){	//wakancja wplynela z prawej strony; atom wyplynal w prawo
+			layer[id_V].eq_flux_delta(0, 0);
+			layer[id_V].eq_flux_delta(typ, 1);
+		}
+
+	}
+	if(id_A >=0 and (id_V != id_A)){
+		//vakancja znika z plastra id_A oraz atom pojawia sie w plastrze id_A
+	//	layer[id_A].flux_net_delta(typ, 1);
+	//	layer[id_A].flux_net_delta(0, 0);
+		if(dir < 0){	//atom wplynal z lewej strony; wakancja wyplynela w lewo
+			layer[id_A].flux_net_delta(typ, 1);
+			layer[id_A].flux_net_delta(0, 0);
+		}
+		if(dir > 0){	//atom wplynal z prawej strony; wakancja wyplynela w prawo
+			layer[id_A].eq_flux_delta(typ, 0);
+			layer[id_A].eq_flux_delta(0, 1);
+		}
+
+	}	
 }
 
-void opcja :: init(lattice* sample, int co_ile, double od_kod, double do_kod, double co_ile_bin, int bin_direction){
+
+void opcja :: call_flux(site* vac_after_jump,site* atom_after_jump){
+
+	double x_A = atom_after_jump->get_position(BIN_DIRECTION);
+	double x_V = vac_after_jump->get_position(BIN_DIRECTION);
+	int typ=atom_after_jump->get_atom();
+	flux_net_add(x_V,x_A,typ,BLOKS);
+	flux_net_add(x_V,x_A,typ,reservuars);
+	flux_add(x_V,x_A,typ,HIST);
 	
+}
+
+void opcja :: init(lattice* sample,vector <double> &parameters ){
+	
+	if(parameters.size()!=6){cout<<"ERROR in opcja::init. Wrong parameters list in conf.in"<<endl;exit(1);}
+	int co_ile = parameters[0];
+	double od_kod = parameters[1];
+	double do_kod = parameters[2]; 
+	double co_ile_bin = parameters[3]; 
+	int bin_direction = parameters[4]; 
+	int if_move = parameters[5];
 	EQ_STEP=co_ile;
 	SAMPLE=0;
 	//dla -1: tylko monitoruj	+biny -rezerwuary +flux	+flux_eq -do_equi
@@ -402,6 +660,7 @@
 
 	MOVE_FRAME = false;
 	SINGLE = true;
+	MOVE_SIM_REGION = (if_move != 0);
 	
 	SAVE_file = "0_";
 	SAVE_step = 0;
@@ -409,6 +668,7 @@
 	SAVE_MCstep = 0;
 	SAVE_MCtime = 0.0;
 	SAVE_AVG = false;
+	SAVE_BUILD = false;
 	
 	BIN_ST=od_kod;
 	BIN_END=do_kod;
@@ -427,7 +687,7 @@
 //	show();
 	
 	//przeliczam stech i vac dla plasterkow
-	for ( int i=0; i < BLOKS.size(); i++){
+	for (unsigned int i=0; i < BLOKS.size(); i++){
 		control_output<<"do init_calc in blok: "<<i<<" "; 
 		BLOKS[i].init_calc(1);
 	}
@@ -440,7 +700,7 @@
 }
 
 void opcja :: build_bins(vector<plaster>& layer){	
-	BLOKS.clear();
+	layer.clear();
 	int ile = (int((BIN_END - BIN_ST)/BIN_SIZE));
 	double miarka[ile];
 	miarka[0]=BIN_ST;
@@ -464,6 +724,7 @@
 		exit(0);
 	}
 	
+	if(parameters.size()!=3){cout<<"ERROR in opcja::init_reservuars. Wrong parameters list in conf.in"<<endl;exit(1);}
 
 	//liczba sitow w plastrze komorek elementarnych
 	double LATT = SAMPLE->get_latice_const(BIN_DIRECTION, 0);
@@ -474,7 +735,7 @@
 
 	double od_kod = parameters[0]; 
 	double width = parameters[1];
-	int direction =int(parameters[3]);
+//	int direction =int(parameters[3]);
 	double do_kod = od_kod + width;
 
 	vector <double> par;
@@ -487,6 +748,8 @@
 	tmp.init_calc(1);
 	
 	reservuars.push_back(tmp);
+	if(reservuars.size()>0){TRYB=1;}else{TRYB=0;}	// 1 - swap/ 0 - convert no reservuars required -> refresh general
+
 }
 
 
@@ -504,7 +767,7 @@
 		control_output<<"ERROR: opcja:move_frame() TYP: "<<TYP_TO_MOVE<<endl;
 		exit(1);
 		}
-	
+	save_write();
 	reinit_reservuars(REZ_TO_MOVE,TYP_TO_MOVE);
 	reinit_bloks();
 
@@ -515,24 +778,20 @@
 	
 };
 
-void opcja :: refresh(){
+void opcja :: refresh(int on){
 
 	//przeliczam stech i vac dla plasterkow
-	for ( int i=0; i < BLOKS.size(); i++){
-		if(SINGLE or MOVE_FRAME){
-			control_output<<"refresh init_calc in blok: "<<i<<" "; 
-			BLOKS[i].init_calc(1);
-		}
-		else{
-			BLOKS[i].init_calc();}
+	for (unsigned int i=0; i < BLOKS.size(); i++){
+				BLOKS[i].init_calc(on);
 	}
 	
-	for ( int i=0; i < reservuars.size(); i++){
-		if(SINGLE or MOVE_FRAME){
-			control_output<<"refresh init_calc in reservuars: "<<i<<" "; 
-			reservuars[i].init_calc(1);	}
-		else{
-			reservuars[i].init_calc();	}
+	for (unsigned int i=0; i < reservuars.size(); i++){
+			reservuars[i].init_calc(on);
+
+	}
+	
+	for (unsigned int i=0; i < HIST.size(); i++){
+			HIST[i].init_calc(on);
 
 	}
 	
@@ -624,21 +883,20 @@
 	SAMPLE->get_sites(BLOKS);
 
 	control_output<<"do init_calc in blok: "<<endl;
-	for ( int i=0; i < BLOKS.size(); i++){
+	for (unsigned int i=0; i < BLOKS.size(); i++){
 		control_output<<i<<" "; 
 		BLOKS[i].init_calc(1);
 	}
 	//show();
 }
 
-
 void opcja :: remove_vac(int b, int vac, bool &FLAG){
 	
 	if(MOVE_FRAME or SINGLE)
 	{control_output<<" r: "<< vac;}
 	
 	bool MOVE = false;
-	int rez = 0, j=-1;
+	int rez = -1, j=-1;
 	
 	
 	for( int i=0; i<(vac);i++){
@@ -784,6 +1042,87 @@
 	}
 }
 
+void opcja :: remove_vac_new(int b, int ile_vac, bool &FLAG){
+	
+	if(ile_vac<0){ile_vac=ile_vac*-1;}
+	unsigned int vac = ile_vac;
+	if(MOVE_FRAME or SINGLE){control_output<<" r: "<< vac;}
+	bool MOVE = false;
+	int rez = -1;
+//	control_output<<"TRYB: "<<TRYB<<endl;
+	vector <int> wybrane_typy; wybrane_typy.reserve(20);
+
+
+//	control_output<<"r: "<<b<<" "<<vac<<": ";
+//	for(int i=0;i<wybrane_typy.size();i++){
+//		control_output<<wybrane_typy[i];
+//	}
+//	control_output<<endl;
+
+	for(unsigned int i=0; i<vac;i++){
+	//		for( int j=1;j<3;j++){		//MOZNA ZROBIC W ZALEZNOSCI OD TYPOW
+			long N1,N2;
+			site* rnd_vac=0;
+			site* rnd_at=0;
+//			j = wybrane_typy[i];	//losuje typ atomu do wymiany z wakancja z blokow
+
+			if(BLOKS[b].size(0) <= 0){
+				control_output<<endl;
+				control_output<<"ERROR: in opcja::remove_vac -> you want to remove \
+				element "<<0<<" that does not exist in blok\n	\
+				Probably error in opcja::init or opcja::reinit_bloks"<<endl; 
+				cout<<endl;
+				cout<<"ERROR: in opcja::remove_vac -> you want to remove \
+				element "<<0<<" that does not exist in blok\n	\
+				Probably error in opcja::init or opcja::reinit_bloks"<<endl;exit(0);
+			}			
+			
+			N1=(long)(rnd()*(BLOKS[b].size(0)));	
+			rnd_vac=BLOKS[b].get_site(0,N1);
+			
+			
+			if(TRYB==1){ //swap
+				rez=choose_reservuar(rnd_vac);
+				int j = choose_typ(reservuars[rez],false);
+				if(j<0){j=j*-1;}
+				MOVE = check_rezervuars(rez,j);	//sprawdz rezerwuwar pod katem dostepnych atomow
+		//			control_output<<"MOVE: "<<MOVE<<" rez: "<<rez<<endl;
+				if (!MOVE){
+					N2=(long)(rnd()*(reservuars[rez].size(j)));
+					rnd_at = reservuars[rez].get_site(j,N2);
+		//			control_output<<" rtyp: "<<rnd_at->get_atom()<<" "<<b<<endl;
+					rnd_at->set_atom(0);
+					rnd_at->reset_site();
+					reservuars[rez].delete_site(j,N2);
+					reservuars[rez].add_site(0,rnd_at);
+					reservuars[rez].prob_update(j,0);
+
+					rnd_vac->set_atom(j);
+					rnd_vac->reset_site();	
+					BLOKS[b].delete_site(0,N1);
+					BLOKS[b].add_site(j,rnd_vac);
+					BLOKS[b].prob_update(j,0);
+				}else{
+					//control_output<<" r: "<< vac;
+					//		if(MOVE_FRAME or SINGLE){control_output<<"||"<<BLOKS[b].size(0)<<"|"<<reservuars[rez].size(0)<<"|"<<reservuars[rez].size(j)<<"|"<<Vtoadd.size()<<">|";}
+					break;
+				}
+			}else{
+				int j = choose_typ(BLOKS[b]);
+				rnd_vac->set_atom(j);
+				rnd_vac->reset_site();	
+				BLOKS[b].delete_site(0,N1);
+				BLOKS[b].add_site(j,rnd_vac);
+				BLOKS[b].prob_update(j,0);
+			}
+	}//end of for j
+	if(MOVE_FRAME or SINGLE){control_output<<endl;}
+	if(MOVE){		
+		FLAG = true;		//set local FLAG in do_equi_vac
+		do_equi_vac();		//rekurencja. Na poczatku sprawdza czy MOVE_FRAME set to TRUE.
+	}
+}
+
 
 void opcja :: refresh_sim_area(vector <site*> &kontener){
 	
@@ -794,14 +1133,14 @@
 		vector <site* > tmp;
 		tmp.reserve(10000);
 		tmp.clear();
-		for (int i=0; i < kontener.size(); i++){
+		for (unsigned int i=0; i < kontener.size(); i++){
 			typ=kontener[i]->get_atom();
 			log=SAMPLE->check_site_belonging_to_sim_area(kontener[i]);
 			if((typ==0) and log ){tmp.push_back(kontener[i]);}
 		}
 		if(SINGLE){control_output<<"|>"<<tmp.size();}
 		//teraz trzeba dodac nowe wakancje z Vtoadd
-		for (int i=0; i < Vtoadd.size(); i++){
+		for (unsigned int i=0; i < Vtoadd.size(); i++){
 			typ=Vtoadd[i]->get_atom();
 			log=SAMPLE->check_site_belonging_to_sim_area(Vtoadd[i]);
 			if( log and (typ == 0) ){tmp.push_back(Vtoadd[i]);}
@@ -813,15 +1152,16 @@
 		Vtoadd.clear();
 		kontener.clear();
 		//przepisz i nadaj Vindexy sitom
-		for (int i=0; i < tmp.size(); i++){
+		for (unsigned int i=0; i < tmp.size(); i++){
 			tmp[i]->set_vindex(i);
 			kontener.push_back(tmp[i]);
 		}
 		if(SINGLE){control_output<<"|= "<<kontener.size()<<endl;}
-	}
-	else{		//bylo przesowanie blokow i rezerwuwarow
+	}else{		//bylo przesowanie blokow i rezerwuwarow
 		control_output<<"opcja::refresh_vac_vector "<<kontener.size()<<endl;
-		SAMPLE -> reinit_sim_area(L_sim, R_sim);			//przesunac obszar symulacji
+		if(MOVE_SIM_REGION){	//przesunac obszar symulacji
+			SAMPLE -> reinit_sim_area(L_sim, R_sim);			
+		}
 		SAMPLE -> set_atoms_list(kontener,0);
 		//resetuj parametry kontrolne przesowania
 		wektor a(0.0,0.0,0.0);
@@ -831,13 +1171,13 @@
 		//clear eq_flux in plasters
 	}
 	if(SINGLE or MOVE_FRAME){
-		for ( int i=0; i < BLOKS.size(); i++){
-		control_output<<"do init_calc in blok: "<<i<<" "; 
+		for (unsigned int i=0; i < BLOKS.size(); i++){
+	//	control_output<<"do init_calc in blok: "<<i<<" "; 
 		BLOKS[i].init_calc(1);
 		}
 		
-		for ( int i=0; i < reservuars.size(); i++){
-		control_output<<"do init_calc in res: "<<i<<" "; 
+		for (unsigned int i=0; i < reservuars.size(); i++){
+	//	control_output<<"do init_calc in res: "<<i<<" "; 
 		reservuars[i].init_calc(1);
 		}
 	}
@@ -864,7 +1204,7 @@
             double data;
        		vector <double> line;
 			istringstream string_line(napis);
-			int line_count=0;
+	//		int line_count=0;
 			while(string_line>>data)
 			{
 		//		cout<<typeid(data).name()<<" "<<data<<endl;
@@ -906,16 +1246,46 @@
 	}
 }
 
+void opcja :: save_build(double iod,double ido,double istep){
+	if(!SAVE_BUILD){
+		double tmp_st=BIN_ST;
+		double tmp_end=BIN_END;
+		double tmp_size=BIN_SIZE;
+		BIN_ST=iod;
+		BIN_END=ido;
+		BIN_SIZE=istep;
+		build_bins(HIST);		
+		BIN_ST=tmp_st;
+		BIN_END=tmp_end;
+		BIN_SIZE=tmp_size;
+
+		SAMPLE->get_sites(HIST);
+		for (unsigned int i=0; i < HIST.size(); i++){
+			control_output<<"do init_calc in hist: "<<i<<" "; 
+			HIST[i].init_calc(1);
+		}
+		SAVE_BUILD=true;
+	}
+}
+
 void opcja :: save_call(double time, long sub_steps){
 	
 	SAVE_MCtime+=time;
 	SAVE_count++;
 	if(SAVE_count<=SAVE_step){
 	refresh();
+	vector<plaster>& wsk2hist=HIST;
 	vector<plaster>& wsk2blok=BLOKS;
-	for(int i =0;i<wsk2blok.size();i++){
-		wsk2blok[i].cumulate();	//dodaje aktualna wartosc parametrow plastra do avg_par's
+	vector<plaster>& wsk2rez=reservuars;
+	for(unsigned int i =0;i<wsk2hist.size();i++){
+		wsk2hist[i].cumulate();	
 		}	
+	for(unsigned int i =0;i<wsk2blok.size();i++){
+		wsk2blok[i].cumulate();	
+		}	
+	for(unsigned int i =0;i<wsk2rez.size();i++){
+		wsk2rez[i].cumulate();	//dodaje aktualna wartosc parametrow plastra do avg_par's
+		}
 	}
 	
 	if(SAVE_count>=SAVE_step){
@@ -927,30 +1297,50 @@
 }
 
 void opcja :: save_write(){
-	string name=SAVE_file+"hist.dat";
-	ofstream data(name.c_str(),ios::app);
+	string name=SAVE_file+"bin.dat";
+	ofstream data_bin(name.c_str(),ios::app);
+	name=SAVE_file+"hist.dat";
+	ofstream data_hist(name.c_str(),ios::app);
+
+	vector<plaster>& wsk2hist=HIST;
 	vector<plaster>& wsk2blok=BLOKS;
+	vector<plaster>& wsk2rez=reservuars;
 	vector<double> results;
 	results.reserve(30);
-	
-	
-	for(int i =0;i<wsk2blok.size();i++){
+	for(unsigned int i =0;i<wsk2blok.size();i++){
 		wsk2blok[i].call_avg(results);
-		data<<SAVE_MCstep<<" "<<SAVE_MCtime<<" "<<i;
-		for(int j=0;j<results.size();j++){
-			data<<" "<<results[j];
+		data_bin<<SAVE_MCstep<<" "<<SAVE_MCtime<<" "<<i;
+		for(unsigned int j=0;j<results.size();j++){
+			data_bin<<" "<<results[j];
 			}
-			data<<endl;
+			data_bin<<endl;
 		
 	}
-	data<<endl;
-	
+	for(unsigned int i =0;i<wsk2rez.size();i++){
+		wsk2rez[i].call_avg(results);
+		data_bin<<SAVE_MCstep<<" "<<SAVE_MCtime<<" "<<i;
+		for(unsigned int j=0;j<results.size();j++){
+			data_bin<<" "<<results[j];
+			}
+			data_bin<<endl;	
+	}	
+	data_bin<<endl;
+	for(unsigned int i =0;i<wsk2hist.size();i++){
+		wsk2hist[i].call_avg(results);
+		data_hist<<SAVE_MCstep<<" "<<SAVE_MCtime<<" "<<i;
+		for(unsigned int j=0;j<results.size();j++){
+			data_hist<<" "<<results[j];
+			}
+			data_hist<<endl;	
+	}	
+	data_hist<<endl;
 }
 
+
 void opcja :: show(){
 
-	for (int i=0;i<BLOKS.size();i++){
-		for (int j=0;j<BLOKS[i].size();j++){
+	for (unsigned int i=0;i<BLOKS.size();i++){
+		for (unsigned int j=0;j<BLOKS[i].size();j++){
 			
 			control_output<<i<<" "<<j<<" "<<BLOKS[i][j]<<endl;
 			BLOKS[i][j]->show_site();
